# 로컬 LLM Serving with Python: Ollama, vLLM, SGLang으로 구축하는 에이전트 추론 시스템


<img src="https://beat-by-wire.gitbook.io/beat-by-wire/~gitbook/image?url=https%3A%2F%2F3055094660-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FYzxz4QeW9UTrhrpWwKiQ%252Fuploads%252FGS6krP9wPXxdK8ZJ5mfb%252FLLM-Router.png%3Falt%3Dmedia%26token%3D80f4d16a-047d-463c-ac8b-63a447fdfa87&width=300&dpr=4&quality=100&sign=9ba1c420&sv=2" width="500" height="707"/>



## 책 소개

인공지능 분야에서 대규모 언어 모델(Large Language Model, LLM)은 가장 혁신적인 기술 중 하나로 자리잡았다. GPT, Claude, Llama와 같은 모델들은 자연어 이해와 생성에서 인간 수준의 성능을 보여주며, 다양한 산업 분야에 적용되고 있다. 그러나 이러한 모델들을 실제 서비스에 활용하려면 단순히 모델을 학습하는 것을 넘어, 효율적으로 추론(inference)을 수행하는 시스템을 구축하는 것이 필수적이다.

초기에는 대부분의 LLM 서비스가 OpenAI, Anthropic, Google과 같은 클라우드 제공자의 API에 의존했다. 이러한 접근은 빠른 시작과 편리함을 제공하지만, 비용, 데이터 프라이버시, 서비스 안정성, 커스터마이징 제약 등의 한계가 명확하다. 특히 대규모 트래픽을 처리하는 기업에게 토큰당 과금 방식은 예측하기 어려운 비용 구조를 만들어낸다. 민감한 데이터를 다루는 의료, 금융, 법률 분야에서는 외부 클라우드로 데이터를 전송하는 것 자체가 규제 위반이 될 수 있다.

이러한 배경에서 로컬 LLM 추론 시스템에 대한 관심이 급증하고 있다. 온프레미스 환경이나 프라이빗 클라우드에서 직접 LLM을 구동하면 데이터 통제권을 완전히 확보할 수 있고, 초기 하드웨어 투자 후에는 한계 비용이 거의 없으며, 자사의 특수한 요구사항에 맞게 모델과 시스템을 커스터마이징할 수 있다. 또한 외부 서비스 장애나 네트워크 문제에 영향받지 않는 안정적인 서비스 제공이 가능하다.

하지만 로컬 LLM 추론 시스템을 구축하는 것은 결코 쉬운 일이 아니다. 대규모 모델은 수십 기가바이트의 메모리를 필요로 하며, 실시간 응답을 제공하려면 복잡한 최적화가 필요하다. 여러 사용자의 요청을 동시에 처리하고, 긴 컨텍스트를 효율적으로 관리하며, 제한된 하드웨어 리소스를 최대한 활용하는 것은 고도의 전문성을 요구한다. 이러한 복잡성을 해결하기 위해 등장한 것이 바로 전문화된 LLM 추론 프레임워크들이다.

본 서는 로컬 LLM 추론 생태계의 세 가지 핵심 프레임워크인 Ollama, vLLM, SGLang을 체계적으로 다룬다. 이 세 프레임워크는 각각 다른 철학과 목표를 가지고 설계되었으며, 서로 다른 사용 사례에 최적화되어 있다. Ollama는 접근성과 사용 편의성을 극대화하여 누구나 쉽게 로컬 LLM을 시작할 수 있게 한다. vLLM은 대규모 프로덕션 환경에서 최고 수준의 성능과 처리량을 제공한다. SGLang은 구조화된 생성과 복잡한 워크플로우를 최적화하여 에이전트 시스템 구축에 강점을 보인다.

각 프레임워크를 단순히 소개하는 것을 넘어, 본 서는 실무에서 즉시 활용할 수 있는 실용적인 지식을 제공하는 것을 목표로 한다. 기본적인 텍스트 생성부터 시작하여, 대화 컨텍스트 관리, 스트리밍 응답, 배치 처리, 성능 최적화까지 단계적으로 학습한다. 특히 각 프레임워크를 활용한 AI 에이전트 구축에 많은 분량을 할애하여, 도구 호출, 의사결정, 복잡한 워크플로우 실행이 가능한 지능형 시스템을 만드는 방법을 상세히 다룬다.

마지막 장에서는 세 프레임워크의 성능을 직접 비교하는 종합 벤치마크를 제시한다. 단일 요청 지연 시간, 배치 처리 성능, 프롬프트 길이별 성능, 메모리 사용량, 동시 사용자 확장성 등 다양한 관점에서 실증적인 데이터를 제공하여, 독자가 자신의 요구사항에 맞는 최적의 프레임워크를 선택할 수 있도록 돕는다.
로컬 LLM 추론은 더 이상 소수의 전문가만이 다루는 영역이 아니다. 적절한 도구와 지식을 갖춘다면 누구나 자신의 환경에서 강력한 AI 시스템을 구축할 수 있다. 본 서가 로컬 LLM 생태계를 탐험하고 실무에 적용하려는 모든 개발자, 엔지니어, 연구자에게 유용한 가이드가 되기를 바란다.

## 목 차


저자 소개

Table of Contents (목차)

서문: 들어가며

제1장: 로컬 LLM 추론 시스템 아키텍처 개요

1.1. Ollama: 접근성을 극대화한 로컬 LLM 생태계
1.2. vLLM: 대규모 추론 서빙을 위한 고성능 엔진
1.3. SGLang: 구조화된 생성과 복잡한 워크플로우의 최적화
1.4. 종합 비교 분석과 선택 가이드
1.5. 하이브리드 아키텍처와 미래 전망

제2장: Ollama 서버 기본

2.1. Ollama를 위한 환경 설정
2.2. Ollama 서버 연결 확인
2.3. Ollama 채팅 생성
2.4. 대화 히스토리 유지하기
2.5. 스트리밍 응답 받기
2.6. 생성 파라미터 조정하기
2.7. 모델 정보 조회하기
2.8. 실용적인 챗봇 예제

제3장: Ollama를 활용한 Agent Serving

3.1. Ollama Agent 환경 설정
3.2. Agent Workflow 구현
3.3. 통합 에이전트 클래스 구현
3.4. 도구 등록 및 에이전트 초기화
3.5. 에이전트 예제 실행
3.6. 에이전트 최종 테스트

제4장: vLLM 서버 기본

4.1. vLLM 서버 환경 설정
4.2. vLLM 서버 연결을 위한 OpenAI 클라이언트 설정
4.3. vLLM 텍스트 생성
4.4. 대화 컨텍스트 유지하기
4.5. 스트리밍 응답 받기
4.6. 배치 처리로 여러 요청 동시 실행
4.7. 생성 파라미터 조정
4.8. 토큰 사용량 확인
4.9. 실용적인 채팅 클래스 구현

제5장: vLLM을 활용한 Agent Serving

5.1. vLLM 에이전트 환경 설정
5.2. Agent Workflow 구현
5.3. vLLM 에이전트 통합 구현
5.4. 도구 등록 및 에이전트 초기화
5.5. 에이전트 예제 실행
5.6. 성능 모니터링 및 분석
5.7 에이전트 최종 테스트

제6장: SGLang 서버 기본

6.1. SGLang 서버 환경 설정
6.1. 텍스트 생성
6.3. 구조화된 출력 생성
6.4. 대화형 프롬프트 작성
6.5. 조건부 생성하기
6.6. 병렬 생성
6.7. RadixAttention 캐싱 활용
6.8. SGLAng 프롬프트 기술
6.9. 실용적인 채팅봇 클래스

제7장: SGLang을 활용한 Agent Serving

7.1. SGLang 에이전트 환경 설정
7.2. Agent Workflow 구현
7.3. SGLangAgent 통합 구현
7.4. 에이전트 초기화 및 설정
7.5. 에이전트 예제 실행
7.6. RadixAttention 성능 테스트
7.7. 종합 상태 및 분석

제8장. LLM Serving 프레임워크 성능 비교: Ollama vs vLLM vs SGLang

8.1. 성능 비교를 위한 기본 세팅
8.2. 테스트 1: 단일 요청 지연 시간 측정
8.3. 테스트 2: 배치 처리 성능 측정
8.4. 테스트 3: 프롬프트 길이별 성능 비교
8.5. 테스트 4: 메모리 사용량 측정
8.6. 테스트 5: 동시 사용자수 확장성 테스트
8.7. 종합 성능 비교표 생성
8.8. 벤치마크 결과

제9장: 결론 - 마무리 하며

References. 참고 문헌

## E-Book 구매

- Yes24: 
- 교보문고: https://ebook-product.kyobobook.co.kr/dig/epd/sam/E000012247160
- 알라딘: http://aladin.kr/p/AEFAs

## Github 코드: 

https://github.com/no-wave/llm-agent-router
